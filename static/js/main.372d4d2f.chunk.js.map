{"version":3,"sources":["components/Radio.js","components/Convert.js","components/Form.js","App.js","serviceWorker.js","index.js"],"names":["Radio","_this$props","this","props","name","id","onChange","type","preview","react_default","a","createElement","class","checked","for","Component","Convert","string","autocomplete","autocorrect","spellcheck","lib","text","onCopy","alert","smiles","Form","state","convstring","handleRadioChange","e","value","_this","replace","target","setState","parseInt","handleConvertChange","_this2","list","map","n","components_Radio","key","components_Convert","App","className","components_Form","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"8OA6BeA,mLAzBJ,IAAAC,EAE8BC,KAAKC,MAAlCC,EAFDH,EAECG,KAAMC,EAFPJ,EAEOI,GAAIC,EAFXL,EAEWK,SAAUC,EAFrBN,EAEqBM,KACtBC,EAAU,SAAIJ,EACpB,OACEK,EAAAC,EAAAC,cAAA,OAAKC,MAAM,SACTH,EAAAC,EAAAC,cAAA,SACEN,GAAIA,EACJO,MAAM,eACNL,KAAK,QACLH,KAAMC,EACNC,SAAUA,EACVO,QAASN,IAASF,IAEpBI,EAAAC,EAAAC,cAAA,OAAKC,MAAM,cACTH,EAAAC,EAAAC,cAAA,OAAKC,MAAM,SACXH,EAAAC,EAAAC,cAAA,SAAOG,IAAKT,EAAIO,MAAM,oBACnBJ,YAnBOO,oBC0BLC,mLAvBJ,IAAAf,EACsBC,KAAKC,MAA1BG,EADDL,EACCK,SAAUW,EADXhB,EACWgB,OAElB,OACER,EAAAC,EAAAC,cAAA,OAAKN,GAAG,WACNI,EAAAC,EAAAC,cAAA,SACEN,GAAK,QACLD,KAAK,SACLc,aAAa,MACbC,YAAY,MACZC,WAAW,QACXd,SAAUA,IAEZG,EAAAC,EAAAC,cAAA,OAAKN,GAAG,UACNI,EAAAC,EAAAC,cAACU,EAAA,gBAAD,CAAiBC,KAAML,EAAQM,OAAQ,kBAAMC,MAAM,0CACjDf,EAAAC,EAAAC,cAAA,UAAKM,aAjBKF,aCEhBU,SAAS,CAAC,eAAM,eAAM,eAAM,eAAM,eAAM,eAAM,SAAK,eAAM,eAAM,eAAM,iBAkD5DC,6MA/CbC,MAAQ,CACNpB,KAAM,EACNU,OAAQ,GACRW,WAAY,MAEdC,kBAAoB,SAAAC,GAClB,IAAMC,EAAQC,EAAKL,MAAMV,OAAOgB,QAAQ,MAAO,KAAOR,EAAOK,EAAEI,OAAO7B,KACtE2B,EAAKG,SAAS,CACZ5B,KAAM6B,SAASN,EAAEI,OAAO7B,IACxBuB,WAAYG,OAIhBM,oBAAsB,SAAAP,GACpB,IAAMC,EAAQD,EAAEI,OAAOH,MAAME,QAAQ,MAAO,KAAOR,EAAOO,EAAKL,MAAMpB,OACrEyB,EAAKG,SAAS,CACZlB,OAAQa,EAAEI,OAAOH,MACjBH,WAAYG,6EAIP,IAAAO,EAAApC,KACHG,EAAK,EACHkC,EAAOd,EAAOe,IAAI,SAAAC,GAAC,OACvBhC,EAAAC,EAAAC,cAAC+B,EAAD,CACEpC,SAAUgC,EAAKT,kBACftB,KAAM+B,EAAKX,MAAMpB,KACjBH,KAAMqC,EACNE,IAAKtC,EACLA,GAAIA,QAIR,OACEI,EAAAC,EAAAC,cAAA,OAAKN,GAAG,QACNI,EAAAC,EAAAC,cAAA,OAAKC,MAAM,aACTH,EAAAC,EAAAC,cAAA,OAAKC,MAAM,oBAAoB2B,IAEjC9B,EAAAC,EAAAC,cAACiC,EAAD,CACEtC,SAAUJ,KAAKmC,oBACfpB,OAAQf,KAAKyB,MAAMC,qBAzCVb,aCYJ8B,0LAbX,OACEpC,EAAAC,EAAAC,cAAA,OAAKmC,UAAU,OACbrC,EAAAC,EAAAC,cAAA,YACEF,EAAAC,EAAAC,cAACoC,EAAD,OAEFtC,EAAAC,EAAAC,cAAA,cACEF,EAAAC,EAAAC,cAAA,0HARQI,cCQEiC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO7C,EAAAC,EAAAC,cAAC4C,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.372d4d2f.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nclass Radio extends Component { \n\n  render() {\n\n    const { name, id, onChange, type } = this.props;\n    const preview = \"ㅡ\"+name;\n    return (\n      <div class=\"input\">\n        <input\n          id={id}\n          class=\"radio-button\"\n          type=\"radio\"\n          name={id}\n          onChange={onChange} \n          checked={type === id}\n        />\n        <div class=\"radio-tile\">\n          <div class=\"icon\"/>\n          <label for={id} class=\"radio-tile-label\">\n            {preview}\n          </label>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Radio;\n","import React, { Component } from \"react\";\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\n\nclass Convert extends Component {\n\n  render() {\n    const { onChange, string } = this.props;\n\n    return (\n      <div id=\"convert\">\n        <input \n          id = \"input\"\n          name=\"string\"\n          autocomplete=\"off\"\n          autocorrect=\"off\"\n          spellcheck=\"false\"\n          onChange={onChange}\n        />\n        <div id=\"result\">\n          <CopyToClipboard text={string} onCopy={() => alert(\"복사됐습니다\")}>\n            <h4>{string}</h4>\n          </CopyToClipboard>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Convert;\n","import React, { Component } from \"react\";\nimport Radio from \"./Radio\";\nimport Convert from \"./Convert\";\nimport \"../form.css\";\n\nconst smiles = [\"̆̈\", \"̆̎\", \"̐̈\", \"̊̈\", \"̑̈\", \"̄̈\", \"̈\", \"̤̮\", \"̤̫\", \"̤̻\", \"̤͓\"];\n\nclass Form extends Component {\n  state = {\n    type: 0,\n    string: \"\",\n    convstring: \"\"\n  };\n  handleRadioChange = e => {\n    const value = this.state.string.replace(/\\S/g, \"$&\" + smiles[e.target.id]);\n    this.setState({\n      type: parseInt(e.target.id),\n      convstring: value\n    });\n  };\n\n  handleConvertChange = e => {\n    const value = e.target.value.replace(/\\S/g, \"$&\" + smiles[this.state.type]);\n    this.setState({\n      string: e.target.value,\n      convstring: value\n    });\n  };\n\n  render() {\n    let id = 0;\n    const list = smiles.map(n => (\n      <Radio\n        onChange={this.handleRadioChange}\n        type={this.state.type}\n        name={n}\n        key={id}\n        id={id++}\n      />\n    ));\n\n    return (\n      <div id=\"form\">\n        <div class=\"container\">\n          <div class=\"radio-tile-group\">{list}</div>\n        </div>\n        <Convert\n          onChange={this.handleConvertChange}\n          string={this.state.convstring}\n        />\n      </div>\n    );\n  }\n}\n\nexport default Form;\n","import React, { Component } from \"react\";\nimport Form from \"./components/Form\";\nimport \"./App.css\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <body>\n          <Form />\n        </body>\n        <footer>\n          <h5>변환된 글자를 클릭하시면 복사됩니다</h5>\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}